/**
 * This file was largely auto-generated by openapi-typescript.
 * It may be easiest to regenerated this file from the contracts API definitions
 * rather than updating this file directly.
 * This file should remain consistent with the contracts API, any types that
 * need to be augmented should be done in types.ts.
 */
export type AccountInfo = {
  name: string;
  id: string;
  createdAt: string;
  /**
   * The external IDs for the account. These will be things like a SF
   * account ID and billing system IDs (e.g., Stripe).
   */
  externalAccountIDs?: ExternalIDs[];
};
export type AuditEvent = {
  eventType?: string;
  source?: string;
  timestamp?: string;
  traceID?: string;
  ids?: string[];
  data?: string;
};
export type ContractRenewalInfo = {
  accountContractInfo: AccountContractInfo;
  renewals: Renewal[];
};
export type AccountContractInfo = {
  accountInfo: AccountInfo;
  contractInfo: ContractInfo;
};
export type AccountUserInfo = {
  accountInfo: AccountInfo;
  userInfo: UserInfo;
};
/**
 * AccountUserAccess holds information on user for which we are
 * setting access rights on an account.
 */
export type AccountUserAccess = {
  /** Email holds the user's email address. */
  email?: string;
  /**
   * AccessLevel holds the account access level. It can be
   * one of the following values: 0 - no access, 1 - admin
   * access or 2 - delegated access.
   */
  accessLevel: number;
};
export type AccountContractStatus = {
  accountInfo?: AccountInfo;
  contractStatus?: ContractStatus[];
};
export type AddContractMachineBody = {
  /** Machine identifier. See MachineInfo.machineId. */
  machineId: string;
  /** Machine architecture; `uname -i` */
  architecture: string;
  os: OS;
  /**
   * Machine host type (physical, vm, container, unknown)
   * In case it's missing or an empty string is provided, "unknown" is
   * implied.
   */
  hostType?: string;
};
export type AddContractMachineResponse = {
  /** New machine token secret */
  machineToken: string;
  machineTokenInfo: MachineTokenInfo;
  /** List of resources with their availability status. */
  availableResources?: AvailableResource[];
  /** resource tokens for all resources which should be enabled by default. */
  resourceTokens?: ResourceToken[];
};
export type AllowanceInfo = {
  metric: string;
  value: number;
};
export type AvailableResourcesResponse = {
  resources?: AvailableResource[];
};
export type AvailableResource = {
  /** Resource name */
  name: string;
  /** resource availability */
  available: boolean;
  /** message describing the service. */
  description?: string;
};
/**
 * Azure instance metadata, compute information. Used for analytics and a
 * fallback method for obtaining subscriptionId. See
 * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service.
 */
export type AzureComputeInstanceMetadata = {
  /** Azure Environment where the VM is running in */
  azEnvironment?: string;
  /** Azure Region the VM is running in */
  location?: string;
  /** Name of the VM */
  name?: string;
  /** Offer information for the VM image. This value is only present for images deployed from Azure image gallery. */
  offer?: string;
  /** Linux or Windows */
  osType?: string;
  /** Placement Group of your virtual machine scale set */
  placementGroupId?: string;
  /** Fault domain the VM is running in */
  platformFaultDomain?: string;
  /** Update domain the VM is running in */
  platformUpdateDomain?: string;
  /** Provider of the VM */
  provider?: string;
  /** Publisher of the VM image */
  publisher?: string;
  /** Resource group for your Virtual Machine */
  resourceGroupName?: string;
  /** Specific SKU for the VM image */
  sku?: string;
  /** Azure subscription for the Virtual Machine */
  subscriptionId?: string;
  /** Tags for your Virtual Machine */
  tags?: string;
  /** Version of the VM image */
  version?: string;
  /** Unique identifier for the VM */
  vmId?: string;
  /** Virtual Machine ScaleSet Name of your virtual machine scale set */
  vmScaleSetName?: string;
  /** VM size */
  vmSize?: string;
  /** Availability Zone of your virtual machine */
  zone?: string;
};
export type GetContractTokenResponse = {
  contractToken: string;
  contractTokenInfo: ContractTokenInfo;
};
export type AffordancesAptRepository = {
  /** Platform architectures for which packages may be provided, such as "x86_64", "ppc64le", "s390x". */
  architectures: string[];
  /** Distribution series for which packages may be provided, such as "trusty", "xenial", "bionic". */
  series?: string[];
};
export type AffordancesLandscape = { [key: string]: unknown };
export type AffordancesLivepatch = {
  /** Platform architectures for which patches may be provided, such as "x86_64", "ppc64le", "s390x". */
  architectures: string[];
  /** Kernel flavors for which patches may be provided, such as "generic", "aws", "ibm". */
  kernelFlavors: string[];
  /** The minimum kernel version required to install livepatch client snap, like "4.4". */
  minKernelVersion: string;
  /** Distribution series for which patches may be provided, such as "trusty", "xenial", "bionic". */
  series?: string[];
  /** Indicate which tier to access (updates is the paid version and standard is the free version) */
  tier: string;
};
export type AffordancesLivepatchOnPrem = {
  /** Indicate which tier to access (updates is the paid version and standard is the free version) */
  tier: string;
};
export type AffordancesPyPIMirror = {
  /** Platform architectures for which packages may be provided, such as "x86_64", "ppc64le", "s390x". */
  architectures: string[];
  /** Distribution series for which packages may be provided, such as "xenial", "bionic", "focal". */
  series?: string[];
};
export type AffordancesAnboxCloudImageServer = { [key: string]: unknown };
export type AffordancesSupport = {
  /** Support level provided, such as "community", "essential", "standard", "advanced" */
  supportLevel: string;
};
/**
 * BillingInfo describes how a renewal or purchase is paid for.
 * The information in this object is obtained immediately after a renewal
 * or purchase is accepted. And it can typically be obtained from
 * elsewhere (e.g. invoices). Its main purposes are troubleshooting and
 * verification. Invoices are the official source of payment information.
 */
export type BillingInfo = {
  /**
   * Identifies the subscription in the external billing system used for
   * the renewal or purchase.
   */
  subscriptionID: string;
  /**
   * Identifies the customer in the external billing system used for the
   * renewal or purchase.
   */
  customerID: string;
  /**
   * Contract user who added the billing information, references
   * UserInfo.ID.
   */
  createdBy: string;
  /**
   * Identifies the remote billing system used for this renewal or
   * purchase. Typically, this is Stripe.
   */
  origin: string;
  /**
   * Identifies the marketplace plan in the external billing system used
   * for the renewal or purchase.
   */
  planID: string;
};
export type ContractInfo = {
  name: string;
  id: string;
  createdAt: string;
  /** Account admin user who created ("entered into", "signed") the contract. */
  createdBy: string;
  /**
   * DEPRECATED: This field is still populated when reading contracts, but will not be
   * accepted for any update operation. Use ContractItems instead, through the "items" field.
   */
  effectiveFrom?: string;
  /**
   * DEPRECATED: This field is still populated when reading contracts, but will not be
   * accepted for any update operation. Use ContractItems instead, through the "items" field.
   */
  effectiveTo?: string;
  products?: string[];
  resourceEntitlements: Entitlement[];
  items?: ContractItem[];
  /**
   * DEPRECATED: This field is still populated when reading contracts, but will not be
   * accepted for any update operation. Use ContractItems instead, through the "items" field.
   */
  allowances?: AllowanceInfo[];
  renewals?: Renewal[];
  /**
   * Associates asset IDs in an external provider (e.g., public cloud) with this contract.
   * DEPRECATED: This field is still populated when reading contracts, but will not be
   * accepted for any update operation. Use ContractItems instead, through the "items" field.
   */
  externalAssetIDs?: ExternalIDs;
  /**
   * The system that generated the contract.
   * DEPRECATED. This field is still populated for free contracts on reading. Otherwise,
   * it will not return any useful information.
   */
  origin?: string;
};
export type ContractStatus = {
  contractInfo?: ContractInfo;
  /** Metrics for this contract. */
  metrics?: ContractMetricStatus[];
  /** Resource status for this contract. */
  resources?: ContractResourceStatus[];
  /**
   * Machine status for this contract.
   * DEPRECATED: please use indirect means of obtaining machine
   * information instead (KPI database or SQL queries).
   */
  machines?: ContractMachineStatus[];
};
export type ContractMetricStatus = {
  /** Metric name */
  metric?: string;
  /** Description of what is measured */
  description?: string;
  /**
   * Contract allowance for this metric. An allowance specifies metric
   * limits allowed by a contract.
   */
  allowance?: number;
  /** Measured value of this metric */
  value?: number;
  /** When the measurement was taken */
  timestamp?: string;
};
export type ContractResourceStatus = {
  /** The type of resource (livepatch, esm, etc.) */
  type?: string;
  /** When the resource was last accessed with this contract */
  lastAccessed?: string;
};
export type ContractMachineStatus = {
  /** Machine id */
  id?: string;
  active?: boolean;
  /** When a machine last accessed a resource using this contract. */
  lastAccessed?: string;
};
/**
 * Information about a contract token.
 * TODO: capabilities, etc.
 */
export type ContractTokenInfo = {
  /** Information on the underlying contract. */
  contractInfo: ContractInfo;
  expires?: string;
};
export type ContractItem = {
  id: number;
  /** ContractID is the ID of the contract to which this item belongs. */
  contractID: string;
  /** Created contains the creation time for the contract item. */
  created: string;
  /** lastModified is the time at which this contract item was last modified. */
  lastModified: string;
  /** EffectiveFrom identifies the time from which the item is valid. */
  effectiveFrom: string;
  /** EffectiveTo identifies the time until which the item is valid. */
  effectiveTo: string;
  /** Metric qualifies the item value. */
  metric: string;
  /** Value is the allowance/asset quantity for this item. */
  value: number;
  /** Reason describes the reason for which a contract item was created. */
  reason: "purchase_made" | "subscription_renewed" | "sf_asset_created";
  /**
   * PurchaseID is the ID of the purchase this item originates from,
   * if applicable (i.e. the item was created because of a Shop
   * purchase).
   */
  purchaseID?: string;
  /**
   * ProductListingID is the ID of the product listing this item
   * originates from, if applicable (i.e. the item was created because
   * of a Shop purchase).
   */
  productListingID?: string;
  /**
   * TrialID is the ID of the trial this item originates from, if
   * applicable (i.e. the item was created because of a Shop trial).
   */
  trialID?: string;
  /**
   * ExternalIDs indicate external IDs (e.g, shop or SF entities) that
   * are related to this contract item.
   * In case of shop IDs, the purchase and product listing ID are also
   * reflected in purchaseID and productListingID fields and you should
   * use those instead.
   */
  externalIDs: ExternalIDs[];
  /**
   * disabled is set when the contract item has been marked as disabled.
   * This is different from the expiration based on effective dates: a
   * contract can be disabled during its effective period.
   */
  disabled?: boolean;
  /**
   * disabledExplanation is an optional string explanation about why the
   * contract item was disabled.
   */
  disabledExplanation?: string;
  /**
   * SubscriptionID points to the subscription of the purchase that led
   * to the creation of this contract item, if any.
   */
  subscriptionID?: string;
  /**
   * Period points to the period of the subscription of the purchase
   * that led to the creation of this contract item, if any.
   */
  period?: string;
};
/**
 * Subscription represents an account's purchases in a
 * marketplace. An account may own subscriptions in each marketplace
 * where it has purchased products.
 */
export type Subscription = {
  /** Unique ID for subscription. */
  id?: string;
  /** Account that owns the subscription. */
  accountID?: string;
  /** Marketplace where subscription was purchased. */
  marketplace?: Marketplace;
  /** Subscription status. */
  status?: "active" | "locked" | "expired";
  /**
   * Identifies the subscription in the external billing system that contains
   * the purchase. Origin must match externalCustomerID.
   */
  externalID?: ExternalIDs;
  /** When the current subscription cycle ends. */
  endOfCycle?: string;
  /**
   * Period describes how often the subscription will be billed. Can be
   * either "yearly", "monthly" or "none", with "yearly" being the default
   * value if not specified.
   */
  period?: string;
  /**
   * AutoRenew specifies if this subscription will automatically renew
   * at the end of the cycle or not.
   */
  autoRenew?: boolean;
};
/**
 * PurchasedProductListing represents the current purchased allowance for
 * a product listing.
 */
export type PurchasedProductListing = {
  /** The product bought by this purchase. */
  productListing: ProductListing;
  value: number;
};
/**
 * SubscriptionDetails associates a subscription with current purchases
 * made under that subscription.
 */
export type SubscriptionDetails = {
  /** Details about the subscription. */
  subscription?: Subscription;
  /**
   * List of all purchased products, including allowances. This will
   * contain all items from the last purchase that was made on the
   * subscription.
   */
  purchasedProductListings?: PurchasedProductListing[];
  /**
   * ID of the last purchase made for the account involving this
   * subscription. Only applies to marketplaces that work on top of the
   * state of last purchases, such as canonical-ua.
   */
  lastPurchaseID?: string;
  /**
   * IDs of the purchases in this subscription that are started or
   * processing.
   */
  pendingPurchases?: string[];
};
/**
 * GetSubscriptionsResponse contains a list of all marketplace
 * subscriptions with the status of purchased allowances.
 */
export type GetSubscriptionsResponse = {
  /** List of all subscriptions. */
  subscriptions?: SubscriptionDetails[];
};
/**
 * EnsurePurchaseAccountResponse contains an account ID along with an
 * optional temporary access token for that account.
 */
export type EnsurePurchaseAccountResponse = {
  /** The account ID. */
  accountID?: string;
  /** a temporary token for account access. */
  token?: string;
};
/**
 * GetInvoiceDetailsResponse represents an invoice, along with the product
 * listings and products mentioned in it.
 */
export type GetInvoiceDetailsResponse = {
  /** The shop invoice. */
  invoice?: ShopInvoice;
  /**
   * The purchase that is referenced in this invoice. Please note that
   * in the case of automatic subscription renewals, this purchase may
   * have been made in the past, and it's just being "repeated"
   * automatically.
   * May not be present if we did not get detailed information from
   * Stripe, which should be a temporary condition.
   */
  purchase?: Purchase;
  /**
   * The purchase that came before the one in this invoice, if any. Can
   * be used to identify what changed in the subscription when comparing
   * with the purchase field.
   */
  previousPurchase?: Purchase;
  /** The subscription associated with the purchase of this invoice. */
  subscription?: Subscription;
  /**
   * Product listings mentioned in the shop invoice. May not be present
   * if we did not get detailed information from Stripe, which should be
   * a temporary condition.
   */
  productListings?: ProductListing[];
  /**
   * Products referenced by the product listings. May not be present if
   * we did not get detailed information from Stripe, which should be
   * a temporary condition.
   */
  products?: Product[];
  /** Contract items created by this purchase. */
  contractItems?: ContractItem[];
};
/**
 * CreatedBy contains basic user information about who created some
 * entity. Usually only used for internal purposes (e.g., giving purchase
 * or trial details to SF).
 */
export type CreatedBy = {
  userID?: string;
  name?: string;
  email?: string;
};
/**
 * GetPurchaseDetailsResponse represents a purchase, along with any
 * related invoices, subscriptions, product listings, products mentioned
 * in it.
 */
export type GetPurchaseDetailsResponse = {
  /** The purchase object. */
  purchase?: Purchase;
  /** The shop invoice related to this purchase, if any. */
  invoice?: ShopInvoice;
  /**
   * The purchase that came before this one, if any. Can be used to
   * identify what changed in the subscription when comparing with the
   * purchase field.
   */
  previousPurchase?: Purchase;
  /** The subscription associated with the purchase of this invoice. */
  subscription?: Subscription;
  /**
   * Product listings mentioned in the shop invoice. May not be present
   * if we did not get detailed information from Stripe, which should be
   * a temporary condition.
   */
  productListings?: ProductListing[];
  /** Products referenced by the product listings. */
  products?: Product[];
  /** Contract items created by this purchase. */
  contractItems?: ContractItem[];
  /**
   * The user who made this purchase. If this purchase represents an
   * automatic renewal, this field will be unset.
   */
  createdBy?: CreatedBy;
};
/** DebugInfo contains full version information about the running server. */
export type DebugInfo = {
  /** Git commit hash. */
  GitCommit?: string;
  /** Version of the server. */
  Version?: string;
};
/** Directives for apt-repository resources such as ESM and FIPS. */
export type DirectivesAptRepository = {
  /** List of packages that should be installed when enabling the entitlement. */
  additionalPackages?: string[];
  /** Apt repository base URL. Required. */
  aptURL: string;
  /**
   * Apt repository signing GPG key. This can be either a public key
   * fingerprint, or an ascii-armored public key. Required.
   */
  aptKey: string;
  /** List of apt suites exposed by the mirror, like "precise" or "trusty-security". */
  suites: string[];
};
/** Resource directives for Landscape. */
export type DirectivesLandscape = {
  /** URL of the Landscape server. This field is required. */
  server?: string;
};
/** Resource directives for Livepatch. */
export type DirectivesLivepatch = {
  /** URL of the Livepatch server. This field is required. */
  remoteServer: string;
  /**
   * CA certificate chain of the Livepatch server in PEM format.
   * Specified for on-prem Livepatch servers secured by a self-signed or internal CA
   * certificate that is not in the core snap CA roots.
   */
  caCerts: string;
};
/** Directives for PyPI mirror resources such as ESM for Python packages. */
export type DirectivesPyPIMirror = {
  /** PyPI mirror base URL. Required. */
  pypiURL: string;
  /** Apt repository base URL from where to install custom pip. Required. */
  aptURL?: string;
  /**
   * Apt repository signing GPG key. This can be either a public key
   * fingerprint, or an ascii-armored public key. Required.
   */
  aptKey?: string;
  /** List of apt suites exposed by the mirror, like "precise" or "trusty-security". */
  suites?: string[];
};
/** Directives for Anbox Cloud image servers. */
export type DirectivesAnboxCloudImageServer = {
  /** Anbox Cloud images base URL. Required. */
  url: string;
};
/**
 * An entitlement describes whether resources are entitled by a contract
 * contract, and if so, answers the questions:
 * - What can a consumer of the resource (typically a machine) do with
 *   them? (Affordances)
 * - What binding terms apply to their use? (Obligations)
 * - What must be done by a consumer in order to access them? (Directives)
 *
 * _Affordances_ determine how a resource may be used within a contract.
 *
 * On a machine, an affordance serves to explain why particular aspects of
 * a resource may or may not be available. Where the resource
 *
 * On the service that provides said resource under a contract,
 * affordances can be used to determine what access should be allowed.
 *
 * For example, a contract provides an affordance for Livepatch which
 * enumerates the kernel flavors eligible to receive patches. The UA
 * machine client does not necessarily use the affordance to configure Livepatch;
 * but it serves to explain to that client why or why not Livepatch is available
 * on the current running system. On the Livepatch server, the affordance
 * can be used to gate whether patches may be provided to a particular machine.
 *
 * _Directives_ consist of resource(service)-specific configuration that
 * is necessary in order for the resource to be used in a given context, but are
 * otherwise not part of the business rules defined by a contract.
 *
 * For example, a customer's machines need to access a dedicated Livepatch
 * server and ESM archives, with custom URLs and root CA certificate. Directives
 * are used to provide this information to the machine, so that it can contact the
 * resource.
 */
export type Entitlement =
  | EntitlementAptRepository
  | EntitlementLandscape
  | EntitlementLivepatch
  | EntitlementLivepatchOnPrem
  | EntitlementPyPIMirror
  | EntitlementAnboxCloudImageServer
  | EntitlementSupport;
/**
 * ExternalIDs are identifiers provided by external systems. Internal
 * entities (e.g., product, account) can be linked to these external
 * systems (identified by origin) based on one or more such IDs.
 */
export type ExternalIDs = {
  /** the external service for which this mapping applies. */
  origin: string;
  /** Origin-specific identifiers. How these identifiers are verified is up to the implementation of the interface with external services. */
  IDs: string[];
};
/** EntitlementBase holds the fields that all entitlement types have in common. */
export type EntitlementBase = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
};
/**
 * EntitlementAptRepository holds entitlement information for the types of
 * resources that talk to an Apt repository.
 */
export type EntitlementAptRepository = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesAptRepository;
  obligations: Obligations;
  directives: DirectivesAptRepository;
  /** Series specific overrides. */
  series?: {
    [key: string]: {
      affordances?: AffordancesAptRepository;
      obligations?: Obligations;
      directives?: DirectivesAptRepository;
    };
  };
};
/**
 * EntitlementLandscape holds entitlement information for the types of
 * resources that talk to a Landscape server.
 */
export type EntitlementLandscape = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesLandscape;
  obligations: Obligations;
  directives: DirectivesLandscape;
  /** Series specific overrides. */
  series?: {
    [key: string]: {
      affordances?: AffordancesLandscape;
      obligations?: Obligations;
      directives?: DirectivesLandscape;
    };
  };
};
/**
 * EntitlementLivepatch holds entitlement information for the types of
 * resources that talk to a Livepatch server.
 */
export type EntitlementLivepatch = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesLivepatch;
  obligations: Obligations;
  directives: DirectivesLivepatch;
  /** Series specific overrides. */
  series?: {
    [key: string]: {
      affordances?: AffordancesLivepatch;
      obligations?: Obligations;
      directives?: DirectivesLivepatch;
    };
  };
};
/**
 * EntitlementLivepatchOnPrem holds entitlement information for the types of
 * resources that allow on-premises Livepatch deployments.
 */
export type EntitlementLivepatchOnPrem = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesLivepatchOnPrem;
  obligations: Obligations;
  directives: DirectivesLivepatch;
};
/**
 * EntitlementPyPIMirror holds entitlement information for the types of
 * resources that talk to a Python Package Index mirror.
 */
export type EntitlementPyPIMirror = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesPyPIMirror;
  obligations: Obligations;
  directives: DirectivesPyPIMirror;
  /** Series specific overrides. */
  series?: {
    [key: string]: {
      affordances?: AffordancesPyPIMirror;
      obligations?: Obligations;
      directives?: DirectivesPyPIMirror;
    };
  };
};
/**
 * EntitlementAnboxCloudImageServer holds entitlement information for the types
 * of resources that talk to an Anbox image server.
 */
export type EntitlementAnboxCloudImageServer = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesAnboxCloudImageServer;
  obligations: Obligations;
  directives: DirectivesAnboxCloudImageServer;
  /** Series specific overrides. */
  series?: {
    [key: string]: {
      affordances?: AffordancesAnboxCloudImageServer;
      obligations?: Obligations;
      directives?: DirectivesAnboxCloudImageServer;
    };
  };
};
/**
 * EntitlementSupport holds entitlement information for resources
 * types that entail support.
 */
export type EntitlementSupport = {
  /** Indicate whether resource access is entitled under the contract. */
  entitled: boolean;
  type: string;
  affordances: AffordancesSupport;
  obligations: Obligations;
};
export type Error = {
  code?: ErrorCode;
  /** Short message describing why the request could not be processed. */
  message: string;
  /** Optional additional information about the error. */
  info?: ContractNotEffectiveInfo;
  /** Correlation ID for log tracing purposes (OpenZipKin for example) if available. */
  traceId?: string;
};
export type ContractNotEffectiveInfo = {
  /** The id of the not effective contract. */
  contractId: string;
  /** Why is the contract not effective. */
  reason: "no-longer-effective" | "not-effective-yet" | "never-effective";
  /**
   * The last time the contract was effective if the reason is "no-longer-effective".
   * When the contract will be effective again if the reason is "not-effective-yet".
   * Not set if the reason is "never-effective".
   */
  time?: string;
};
/**
 * A code representing the kind of error.
 * TODO enumerate all the possible error codes here?
 */
export type ErrorCode = string;
/** A user's information. */
export type UserInfo = {
  /** The user's ID. */
  id?: string;
  /** The user's email address. */
  email?: string;
  /** The user's username. */
  name?: string;
  /** The user's display name. */
  displayName?: string;
  /** The verified status of the user's email in Ubuntu SSO. */
  verified?: boolean;
  /** The date of the user first log in. */
  firstLogin?: string;
  /** The date of the user most recent log in. */
  lastLogin?: string;
};
/** List of user accounts. */
export type GetAccountsResponse = {
  accounts: AccountInfo[];
  errors?: Error[];
};
/** A macaroon with a third-party caveat addressed to Ubuntu SSO. */
export type GetCanonicalSSOMacaroonResponse = {
  /** Macaroon value encoded using version 1 binary format and URL safe base64 without any padding characters. */
  macaroon: string;
};
/** List of contracts. */
export type GetContractsResponse = {
  contracts: AccountContractInfo[];
  errors?: Error[];
};
/** List of users. */
export type GetUsersResponse = {
  users: AccountUserInfo[];
};
/** List of products */
export type GetProductsResponse = {
  products: Product[];
};
export type GetResourceContractAccessResponse = {
  entitlement: Entitlement;
  /** token for use to access the resource */
  resourceToken?: string;
};
export type GetResourceMachineAccessResponse = {
  entitlement: Entitlement;
  /** token for use to access the resource */
  resourceToken?: string;
};
export type GetResourceTokenInfoResponse = {
  /** The contract ID to which this token belongs. */
  contractId: string;
  /**
   * The machine ID to which this token belongs.
   * See MachineInfo.machineId.
   */
  machineId: string;
  /**
   * Affordances that apply to the resource, only present if resource
   * access is granted.
   */
  affordances?: { [key: string]: unknown };
  /**
   * Error on checking resource access, only present if resource access
   * is denied. The value of the code field may be one of:
   *   "resource forbidden", "machine not found", "contract not found".
   */
  error?: Error;
};
export type MachineInfo = {
  /**
   * Obfuscated machine ID, derived from local systemd /etc/machine-id.
   * See https://www.freedesktop.org/software/systemd/man/machine-id.html#
   * for more information on how this should be generated by the client.
   */
  machineId: string;
  /** The contract ID. */
  contractId?: string;
  /** Machine architecture; `uname -i` */
  architecture: string;
  os: OS;
  resourceAccesses: ResourceAccess[];
  /**
   * Machine host type (physical, vm, container, unknown).
   * Empty string should be interpreted as unknown.
   */
  hostType?: string;
};
export type MachineTokenInfo = {
  /** Machine identifier. See MachineInfo.machineId. */
  machineId: string;
  accountInfo: AccountInfo;
  contractInfo: ContractInfo;
  expires?: string;
};
/**
 * _Obligations_ are policies that are contractually required to be
 * implemented. It may need to be implemented by the context (machine) or resource (service).
 * It may be checked for compliance by an auditing system or process.
 *
 * For example, a machine may be obligated to enable a resource by default
 * if it is available, when that machine is associated with the contract.
 */
export type Obligations = {
  enableByDefault: boolean;
} & { [key: string]: string };
export type ODMCertificate = {
  /** ID of the certificate (10 characters long). */
  id?: string;
  /** ID of the associated account. */
  accountID?: string;
  /** ID of the associated product. */
  productID?: string;
  /** Name of the Original Development Manufacturer. */
  manufacturer?: string;
  /** Name of the associated device. */
  deviceName?: string;
};
export type ODMSerialNumber = {
  /** Serial number ID. */
  id?: string;
  /** ID of the associated certificate. */
  certificateID?: string;
  /** ID of the serial number batch. */
  batchID?: string;
  /** Hardware hash of the associated device. */
  hardwareHash?: string;
};
/** List of serial numbers. */
export type GetODMSerialNumbersResponse = {
  serialNumbers: ODMSerialNumber[];
};
/** List of certificates. */
export type GetODMCertificatesResponse = {
  certificates: ODMCertificate[];
  errors?: Error[];
};
export type EntityWithExternalIDs = {
  /** id for the the entity. */
  id?: string;
  /**
   * The external IDs for the entity. These will be things like a SF
   * account ID and billing system IDs (e.g., Stripe).
   */
  externalIDs?: ExternalIDs[];
};
/** Contains list of entities matching the provided external id. */
export type GetEntitiesWithExternalIDResponse = {
  accounts?: EntityWithExternalIDs[];
  contracts?: EntityWithExternalIDs[];
  contractItems?: EntityWithExternalIDs[];
  products?: EntityWithExternalIDs[];
  productListings?: EntityWithExternalIDs[];
  renewals?: EntityWithExternalIDs[];
  purchases?: EntityWithExternalIDs[];
  subscriptions?: EntityWithExternalIDs[];
};
export type OS = {
  /** OS distribution name; `lsb_release -d` */
  distribution: string;
  /** OS release name; `lsb_release -r` */
  release: string;
  /** Distribution series or code name; `lsb_release -c` */
  series: string;
  /** OS type; for example, "Linux", "Windows", "OpenBSD" */
  type: string;
  /** Full kernel version including patch version and flavor; for example, "4.15.0-39.42-generic" */
  kernel: string;
};
export type Product = {
  /** Product ID */
  id: string;
  /** Product Name */
  name: string;
  /** Resources enabled by this product. */
  resourceEntitlements: Entitlement[];
  /** A list of tags associated with this product. */
  tags?: string[];
  /**
   * DEPRECATED: needs to be migrated to ProductListing!
   * Associates product IDs in an external provider (e.g., public cloud)
   * with this product.
   */
  externalMarketplaceIDs?: ExternalIDs;
  /**
   * DEPRECATED: needs to be migrated to ProductListing!
   * The external IDs for the product in external billing systems.
   * Please note that externalMarketplaceIDs currently implements this
   * mapping for cloud marketplaces and should still be used for that
   * purpose.
   */
  externalBillingIDs?: ExternalIDs[];
};
/** List of matching product listings. */
export type GetProductListingsResponse = {
  productListings: ProductListing[];
  products: Product[];
};
/** Product listing in a marketplace, with a price, external marketplace and billing ids. */
export type ProductListing = {
  /** ID holds the product listing ID. */
  id: string;
  /**
   * Name of the product listing. No two active product listings
   * may share the same name.
   */
  name?: string;
  /** ProductID holds the product ID. */
  productID: string;
  /** CreatedAt holds the time of the product listing creation. */
  createdAt?: string;
  /** LastModifiedAt holds the time of the last update of the product listing. */
  lastModifiedAt?: string;
  /** Status holds the status of the product listing. */
  status?: 'active"' | "archived";
  /** ReplacedProductListingID holds the ID of the product listing this product listing replaces. */
  replacedProductListingID?: string;
  /** Marketplace names the marketplace where this product is listed. */
  marketplace: Marketplace;
  /** PrivateAccountID holds the id of the account that may access this product listing. */
  privateAccountID?: string;
  /**
   * BundleQuantity indicates that the product is sold in bundles of a fixed quantity.
   * When purchased, contracts will add units of AllowanceMetric in multiples of BundleQuantity.
   * Assumed to be 1 if not otherwise specified.
   */
  bundleQuantity?: number;
  /**
   * TrialDays indicates the number of days this product is triable
   * for. If set to 0, this indicates this product listing is not
   * triable.
   */
  trialDays?: number;
  /**
   * EffectiveDays indicates, optionally, the number of days the
   * contract resulted from purchasing this listing should be effective
   * for. This applies for one-off purchases, whereas 'Period'
   * applies for subscribable listings.
   */
  effectiveDays?: number;
  /** Price of purchasing this product listing. */
  price?: Price;
  /** AllowanceMetric names the metric that is to be used when creating an allowance for this product. */
  allowanceMetric?: string;
  /**
   * ExternalMarketplaceIDs associate product listing to an external marketplace (e.g public cloud).
   *
   * DEPRECATED: please use externalIDs instead.
   */
  externalMarketplaceIDs?: ExternalIDs;
  /**
   * ExternalIDs associate product listing to external marketplaces where this listing is
   * operating (e.g. public cloud, Salesforce, etc.).
   */
  externalIDs?: ExternalIDs[];
  /**
   * ExternalPricingID associates product listing to an external pricing system.
   *
   * In product listing creation, the value for this field will be assumed as
   * that of an existing external pricing ID to be associated with this product listing.
   *
   * Otherwise, this field may be auto-populated based on the marketplace.
   * For example, in the Canonical UA marketplace, a Stripe plan will be created
   * and its reference will be added here.
   */
  externalPricingID?: ExternalIDs;
  /** Metadata describing the product listing. */
  metadata?: KeyValue[];
  /**
   * Period describes how often the subscription will be billed. Can be
   * either "yearly", "monthly" or "none", with "yearly" being the default
   * value if not specified.
   */
  period?: string;
};
/** KeyValue holds a key and an associated value. */
export type KeyValue = {
  key?: string;
  value?: string;
};
/**
 * Marketplace identifies where certain products are listed and
 * may be purchased.
 */
export type Marketplace = "canonical-ua";
/** Price information for renewals. */
export type Price = {
  /** The price value in currency. e.g. a value of 7500 in USD would by 75.00 */
  value?: number;
  /** The price currency. */
  currency?: string;
  /** The number of months the value refers to. */
  months?: number;
};
/** PutMachineUsageRequestBody contains machine usage metered against an allowance. */
export type PutMachineUsageRequestBody = {
  metrics: MachineUsageMetric[];
};
/** Machine usage metered against an allowance. */
export type MachineUsageMetric = {
  resource?: string;
  metric: string;
  value: number;
};
/** EnsureContractRequestBody contains the data required to create or update a contract. */
export type EnsureContractRequestBody = {
  /** Account ID */
  accountInfo: AccountInfo;
  /** The info for this contract. */
  contractInfo: ContractInfo;
  /** Salesforce users associated with the Salesforce account. */
  users: UserInfo[];
  /** Salesforce renewal information. */
  renewals: Renewal[];
};
/**
 * Purchase defines a purchase of one or more products in a marketplace,
 * made by an account, possibly on a subscription.
 */
export type Purchase = {
  /** ID holds the purchase ID. */
  id: string;
  /** The marketplace in which this purchase was made. */
  marketplace?: string;
  /** The items for this purchase. */
  purchaseItems: PurchaseItem[];
  /** The account making the purchase. */
  accountID: string;
  /** Indicates the status of the purchase. */
  status: "pending" | "starting" | "processing" | "done";
  /** When the renewal was created. */
  createdAt?: string;
  /** Who created the renewal. */
  createdBy?: string;
  /** Time the renewal was last updated. */
  lastModified?: string;
  /**
   * Summary information about the Stripe invoice related to this
   * purchase. Only applies to marketplaces that bill purchases using
   * Stripe. This is an array for historical reasons. At most one item
   * will ever be present in this array.
   * DEPRECATED: this field is still available and supported, but the
   * invoice field should be used instead.
   */
  stripeInvoices?: ShopInvoiceStripePaymentSummary[];
  /**
   * The shop invoice related to this purchase. Only returned when a
   * purchase is directly requested by the user who started it. This
   * invoice may contain further direction for payment in case it has
   * not been concluded yet.
   */
  invoice?: ShopInvoice;
  /** ID of the subscription that was affected by this purchase (if any). */
  subscriptionID?: string;
  /**
   * Indicates whether this purchase is for the renewal of a
   * subscription.
   */
  isRenewal?: boolean;
  /** Indicates the ID of the offer this purchase is related to, if any. */
  offerID?: string;
  /**
   * Indicates the ID of the manual renewal this purchase is related to,
   * if any.
   */
  renewalID?: string;
  /** Indicates the ID of the trial this purchase is related to, if any. */
  trialID?: string;
  /**
   * Start indicates the start date of this purchase effectiveness. If
   * it's a purchase on a subscription, it will be the period start for
   * the subscription cycle in which the purchase happened. If it's a
   * one-off purchase, it will be the date at which the purchase effects
   * end.
   */
  start?: string;
  /**
   * End indicates the end date of this purchase effectiveness. If it's
   * a purchase on a subscription, it will be the period end for the
   * subscription cycle in which the purchase happened. If it's a
   * one-off purchase, it will be the date at which the purchase effects
   * end.
   */
  end?: string;
  /**
   * Applies a discount coupon to this purchase. The origin must match
   * that of the billing mechanism used by the marketplace (see the
   * documentation of each marketplace for details).
   */
  coupon?: ExternalIDs;
  /**
   * Metadata associated with this purchase (e.g., IDs of related
   * entities outside the scope of the shop, like campaign IDs).
   */
  metadata?: KeyValue[];
};
/** Contains a purchase along with all related product listings. */
export type Purchases = {
  /** Purchases. */
  purchases?: Purchase[];
  /** All related product listings. */
  productListings?: ProductListing[];
  purchase: unknown;
};
/** Defines a purchase of one or more products, made by an account. */
export type PurchaseRequest = {
  /** The items for this purchase. */
  purchaseItems: PurchaseItem[];
  /** The account making the purchase. */
  accountID: string;
  /**
   * The ID of the previous purchase. Only required for marketplaces
   * that work on top of the state of last purchases, such as
   * canonical-ua.
   */
  previousPurchaseID?: string;
  /** Indicates the ID of the offer this purchase is related to, if any. */
  offerID?: string;
  /**
   * Indicates the ID of the manual renewal this purchase is related to,
   * if any.
   */
  renewalID?: string;
  /**
   * The trial ID that lead to this purchase. A customer may customize
   * the purchase derived from a trial, so this attribute is for
   * bookkeeping purposes only and has no practical effects.
   */
  trialID?: string;
  /**
   * Applies a discount coupon to this purchase. The origin must match
   * that of the billing mechanism used by the marketplace (see the
   * documentation of each marketplace for details).
   */
  coupon?: ExternalIDs;
  /**
   * Metadata associated with this purchase (e.g., IDs of related
   * entities outside the scope of the shop, like campaign IDs).
   */
  metadata?: KeyValue[];
};
/** PurchaseItem contains the definition of a purchase item. */
export type PurchaseItem = {
  /** The product bought by this purchase. */
  productListingID: string;
  value: number;
  /**
   * Delete signals that all previous allowances for the product listing
   * should be removed from the subscription. Only applies when making
   * a purchase.
   */
  delete?: boolean;
};
/**
 * Defines a request for trial of one or more products, made by an
 * account.
 */
export type EnsureTrialRequestBody = {
  /**
   * The trial ID to update. If not given, it is assumed that
   * a new trial will be started with the given items.
   */
  trialID?: string;
  /** The account starting the trial. */
  accountID: string;
  /** The items for this trial. */
  items: TrialItem[];
  /**
   * Customer information to be associated with the trial. Each
   * marketplace has its own requirements:
   *   - canonical-ua: requires customer name and country.
   */
  customerInfo?: StripeCustomerInfo;
};
/**
 * Defines a trial of one or more products and the contract items that
 * were created as a result of it.
 */
export type Trial = {
  /** The trial ID. */
  id?: string;
  /** The account starting the trial. */
  accountID: string;
  /** The items for this trial. */
  items: TrialItem[];
  /** The time at which this trial was created. */
  createdAt: string;
  /** The time at which this trial was modified. */
  lastModifiedAt?: string;
  /** The marketplace to which this trial applies. */
  marketplace?: string;
  /**
   * A convenient field that indicates when this trial expires. This
   * is determined based on the status of the contract items involved in
   * this trial. An expired trial may be converted into a purchase
   * without any issues.
   */
  expiresAt: string;
  /**
   * Contract items created for this trial. These contract items can be
   * used to determine the status of the trial (i.e., if it expired, how
   * long ago, etc.).
   */
  contractItems?: ContractItem[];
  /** The ID of the purchase that originated from this trial, if any. */
  purchaseID?: string;
};
/**
 * Defines a request for an offer of one or more products, made for an
 * account.
 */
export type EnsureOfferRequestBody = {
  /** OfferID to update. If not given, a new offerID will be created. */
  offerID?: string;
  /** The account for which the offer is attached. */
  accountID: string;
  /** Actionable defines if the offer can be acted on. */
  actionable?: boolean;
  /** Items included in the offer. */
  items: OfferItem[];
  /**
   * This associates an offer with the related entities in external
   * systems.
   */
  externalIDs: ExternalIDs;
};
/** Defines an offer of one or more products for an account. */
export type Offer = {
  /** id of the offer. */
  id?: string;
  /** createdAt is the time at which this offer was created. */
  createdAt: string;
  /** lastModified is the time at which this offer was last modified. */
  lastModified: string;
  /** The account for which the offer is attached. */
  accountID: string;
  /** Actionable defines if the offer can be acted on. */
  actionable: boolean;
  /** Items included in the offer. */
  items: OfferItem[];
  /**
   * This associates an offer with the related entities in external
   * systems.
   */
  externalIDs: ExternalIDs[];
  /** The purchase linked to this offer, if available. */
  purchaseID?: string;
};
/** TrialItem contains the definition of a trial item. */
export type TrialItem = {
  /** The product bought by this trial item. */
  productListingID: string;
  /** The quantity being asked for trialing this item. */
  value: number;
};
/**
 * OfferItem represents a number of units for a certain listing that
 * are included in an offer.
 */
export type OfferItem = {
  /** The product bought by this offer item. */
  productListingID: string;
  /** The offered quantity. */
  value: number;
};
/**
 * Defines a trial of one or more products and the contract items that
 * were created as a result of it, including customer information.
 */
export type GetTrialDetailsResponse = {
  /** contains trial details. */
  trial: Trial;
  /**
   * Contains the Stripe customer details for the account in which this
   * trial was started.
   */
  customerInfo: StripeCustomerInfo;
  /** The user who started this purchase. */
  createdBy?: CreatedBy;
  /**
   * A list of (contract ID, machine count) pairs indicating how many
   * machines were attached to each contract created by this trial.
   */
  attached?: ContractMachineCount[];
};
/**
 * Defines the number of machines attached to a given contract. Meant to
 * be used only by endpoints that return information about multiple
 * contracts at the same time.
 */
export type ContractMachineCount = {
  /** The contract ID. */
  contractID: string;
  /** The number of machines attached to this contract. */
  machineCount: number;
};
/** Renewal contains the definition of a renewal. */
export type Renewal = {
  /** ID of the renewal. */
  id?: string;
  /** The items for this renewal. */
  renewalItems?: RenewalItem[];
  /** When the renewal should be shown to the user */
  start?: string;
  /** When the renewal is no longer valid */
  end?: string;
  /**
   * Associates an account ID in an external provider (e.g., public
   * cloud) with this renewal.
   */
  externalAccountID?: ExternalIDs;
  /**
   * Associates asset IDs in an external provider (e.g., public cloud)
   * with this renewal.
   */
  externalAssetIDs?: ExternalIDs;
  /** When the renewal was created. */
  createdAt?: string;
  /** Who created the renewal. */
  createdBy?: string;
  /** Time the renewal was last updated. */
  lastModified?: string;
  /** ID of the contract associated with this renewal. */
  contractID?: string;
  /** Status of the renewal. */
  status?: string;
  /** Billing information for the renewal */
  billing?: BillingInfo;
  /** Indicates if this renewal can be effectively renewed or not. */
  actionable?: boolean;
  /**
   * The Stripe invoices related to this renewal. Invoices in this list
   * are guaranteed to be sorted from most recently updated to least
   * recently updated.
   */
  stripeInvoices?: StripeInvoice[];
  /**
   * NewContractStart holds the start date or the renewed
   * contract should the renewal be accepted.
   */
  newContractStart?: string;
};
/** RenewalItem contains the definition of a renewal item. */
export type RenewalItem = {
  /**
   * Contract allowance for this metric. An allowance specifies metric
   * limits allowed by a contract.
   */
  allowance?: AllowanceInfo;
  /** Price per unit. */
  pricePerUnit?: Price;
  /** Total price. */
  priceTotal?: Price;
};
/** Stripe customer address information. */
export type StripeCustomerAddress = {
  line1: string;
  line2: string;
  city: string;
  country: string;
  postal_code: string;
  state: string;
};
/** Stripe customer address information. */
export type StripePaymentMethod = {
  /** Payment method ID from Stripe. */
  id: string;
  /** Credit card brand. Only set in responses to get requests. */
  brand?: string;
  /** Credit card country. Only set in responses to get requests. */
  country?: string;
  /** Credit card expiration month. Only set in responses to get requests. */
  expMonth?: number;
  /** Credit card expiration year. Only set in responses to get requests. */
  expYear?: number;
  /** Last 4 digits of the credit card. Only set in responses to get requests. */
  last4?: string;
};
export type StripeTaxID = {
  /**
   * Stripe tax type information, see:
   * https://stripe.com/docs/billing/taxes/tax-ids
   */
  type: string;
  /**
   * The actual Stripe tax ID; this value passes basic validation
   * (format) by Stripe based on the type field. Further validation,
   * including verifications if this is a valid number belonging to the
   * customer is NOT performed by this service. See:
   * https://stripe.com/docs/billing/taxes/tax-ids
   */
  value: string;
  /**
   * Delete signals that the existing tax ID must be removed and nothing
   * should be set in its place (type and value are ignored if this is
   * set).
   */
  delete?: boolean;
};
/** The balance a customer has on the shop. */
export type CustomerBalance = {
  /**
   * The current balance in the base units of the currenty. For
   * example, a value of 7500 in USD would be 75.00. A positive value
   * indicates a credit, and a negative value indicates a debt.
   */
  value?: number;
  /** The currency of the balance. */
  currency?: string;
};
export type StripeCustomerInfo = {
  /**
   * Customer name.
   * On create: required.
   * On update: if unspecified, the existing name will be kept.
   * Please note that this should usually be a person to which invoices
   * will be directed, and not a company name (the company name should
   * be in the account name instead).
   */
  name?: string;
  /**
   * Customer email.
   * On create: output only, ignored as input.
   * On update: output only, ignored as input.
   * This is a read-only field that is automatically populated based on
   * the user who is making the request, so it doesn't need to be
   * provided.
   */
  email?: string;
  /**
   * Customer address.
   * On create: required that at least country is set.
   * On update: if unspecified, the current address will be kept. If
   * partially specified, unspecified fields will be set to empty,
   * except for country, which is required.
   */
  address?: StripeCustomerAddress;
  /**
   * Customer national tax ID (format varies by country).
   * On create: optional.
   * On update: if unspecified, the current tax ID will be kept. If
   * specified with the delete flag set, any current tax ID will be
   * removed.
   */
  taxID?: StripeTaxID;
  /**
   * Default payment method in Stripe.
   * On create: optional.
   * On update: if unspecified, current payment method is kept as is.
   * If specified, the payment method will be attached and made default.
   * Previous payment methods will still be attached (but unaccessible).
   */
  defaultPaymentMethod?: StripePaymentMethod;
  /**
   * On create: output only, ignored as input.
   * On update: output only, ignored as input.
   * Customer balance in the shop. If not present, it means the customer
   * currently holds an empty/neutral balance. This is a read-only
   * field.
   */
  balance?: CustomerBalance;
  /**
   * Stripe payment method ID.
   * DEPRECATED: this is available only for backwards compatibility. It
   * behaves the same as defaultPaymentMethod.id (which should be used
   * instead).
   */
  paymentMethodID?: string;
};
/** Stripe customer address and payment method information. */
export type GetStripeCustomerInfoResponse = {
  /** The account info, including the Stripe customer ID. */
  accountInfo?: AccountInfo;
  /** The customer info, will be present and empty if not set. */
  customerInfo?: StripeCustomerInfo;
};
export type StripeInvoice = {
  /** Stripe invoice ID. */
  invoice_id?: string;
  /** Stripe subscription ID. */
  subscription_id?: string;
  /** Contract ID. */
  contract_id?: string;
  /** Stripe payment intent status. */
  pi_status?: string;
  /** Stripe payment intent decline code. */
  pi_decline_code?: string;
  /**
   * Stripe payment intent client secret for payment authentication. May
   * not be present in some invoices (e.g., those with a total of 0 or
   * less).
   */
  pi_secret?: string;
  /** Stripe subscription status. */
  subscription_status?: string;
  /** Time at which payment information was last updated. */
  last_update?: string;
};
/**
 * ShopInvoiceStripePaymentSummary represents a minimal set of fields that
 * are used to indicate the status of an invoice payment in Stripe. It is
 * meant to be used by clients that are handling payments. This type is
 * deprecated and should not be used (suitable alternatives are indicated
 * in places where this type is still used).
 */
export type ShopInvoiceStripePaymentSummary = {
  /** Stripe invoice ID. */
  id?: string;
  /** Stripe payment intent status. */
  pi_status?: string;
  /** Stripe payment intent decline code. */
  pi_decline_code?: string;
  /**
   * Stripe payment intent client secret. May not be present  in some
   * invoices (e.g., those with a total of 0 or less).
   */
  pi_secret?: string;
  /** Stripe subscription status. */
  subscription_status?: string;
  /** Time at which invoice information was last updated. */
  last_update?: string;
};
/** ShopInvoice represents an invoice line item in a shop invoice. */
export type ShopInvoiceLineItem = {
  description?: string;
  planID?: ExternalIDs;
  quantity?: number;
  proRatedAmount?: number;
  currency?: string;
};
export type PaymentStatus = {
  /** Describes the current situation of a payment. */
  status?:
    | "need_3ds_authorization"
    | "need_another_payment_method"
    | "processing"
    | "paid";
  /**
   * The client secret to be used for 3DS authorization. Only present if
   * situation is need_3ds_authorization and the user making the request
   * is the one who started the purchase related to this invoice.
   */
  piClientSecret?: string;
  /**
   * A string representing the last payment error. Only present if the
   * status is need_another_payment_method. Possible values are the
   * decline codes used in the Stripe API, see:
   *   https://stripe.com/docs/declines/codes
   */
  lastPaymentError?: string;
};
/** ShopInvoice represents an invoice in the shop. */
export type ShopInvoice = {
  id?: ExternalIDs;
  identifier?: string;
  customerName?: string;
  customerEmail?: string;
  customerAddress?: StripeCustomerAddress;
  reason?: string;
  subscriptionID?: ExternalIDs;
  subscriptionStartOfCycle?: string;
  subscriptionEndOfCycle?: string;
  currency?: string;
  lineItems?: ShopInvoiceLineItem[];
  taxAmount?: number;
  total?: number;
  amountDue?: number;
  amountPaid?: number;
  amountRefunded?: number;
  appliedBalance?: number;
  /**
   * The status of the invoice. Possible values are the those used in
   * the Stripe API, see:
   *   https://stripe.com/docs/billing/invoices/overview
   */
  status?: string;
  paid?: boolean;
  /** The situation of the payment associated with this invoice. */
  paymentStatus?: PaymentStatus;
  /** The URL for a downloadable version of the invoice. */
  url?: string;
};
export type ResourceAccess = {
  /** Type of resource */
  resourceType?: string;
  /** Time the resource was last accessed. */
  accessTime?: string;
};
export type ResourceToken = {
  /** type of resource the token is for. */
  type?: string;
  /** token for use to access the resource */
  token?: string;
  resourceName: unknown;
  resourceToken: unknown;
};
/** Body of the SetServiceAccountPassword request. */
export type SetServiceAccountPasswordBody = {
  /** Password to set for the service-account. */
  password: string;
};
