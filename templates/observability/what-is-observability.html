{% extends "observability/base_observability.html" %}

{% block title %}What is observability{% endblock %}

{% block meta_description %}What is observability, the difference between observability and monitoring (observability vs monitoring), and how are the different types of telemetry collected and analyzed in the state of the art of open-source observability.{% endblock %}

{% block meta_copydoc %}https://docs.google.com/document/d/1eoqDQzFiRJY2u_EO4JBuLBLqae4K3nrEf3qd88KHw0Y/edit{% endblock meta_copydoc %}

{% block content %}

<section class="p-strip u-no-padding--top u-no-padding--bottom">
    <div class="p-strip--suru-topped">
        <div class="row u-equal-height">
            <div class="col-8">
                <h1>What is observability?</h1>
                <p>Your software system is observable when the telemetry you collect and the way you process it enables you to know and investigate in a timely fashion how your software system is performing, what issues are occurring and what their impact is.</p>
            </div>
            <div class="col-4 u-align--center u-vertically-center u-hide--medium u-hide--small">
                {{ image (
                    url="https://assets.ubuntu.com/v1/db240da7-K8s_management_platform-01.svg",
                    alt="",
                    width="350",
                    height="250",
                    hi_def=True,
                    loading="lazy"
                    ) | safe
                }}
            </div>
        </div>
    </div>
</section>

<section class="p-strip--light">
    <div class="row">
        <div class="col-8">
            <h2>Observability vs. monitoring</h2>
            <h3 class="p-heading--4">Rather, observability through monitoring</h3>
            <p>The term "monitoring" is sometimes used to denote the collection and processing of metrics, and especially timeseries. Instead, we define monitoring more generally as the act and practice of collecting and processing useful telemetry to gain insight in the behavior of a system.</p>
            <p>In the current practice of software, and especially in distributed systems and cloud-native software, monitoring is the commonplace means of achieving observability. Tools like Prometheus, OpenTelemetry, Jaeger, Elasticsearch or Graylog document the relevant workings of software systems by collecting and processing various telemetry types, such as metrics, distributed traces and logs.</p>
        </div>
        <div class="col-4 u-vertically-center">
            <div style="background-color:#fff; border: 1px solid #eee; padding: 1rem;">
                <p>Read our <a href="/blog/observability-vs-monitoring-debate-an-irreverent-view">"Observability vs. monitoring debate: An irreverent view"</a> blog post for an in-depth look at the debate around "observability vs. monitoring".</p>
            </div>
        </div>
  </div>
</section>

<section class="p-strip">
    <div class="row u-equal-height">
        <div class="col-8">
            <h2>Monitoring and telemetry types</h2>
            <p>In today's open source monitoring practices, there are several types of telemetry being collected:</p>
        </div>
    </div>
    <br>
    <div class="row u-equal-height">
        <div class="col-7">
            <h3 class="p-heading--4">Metrics</h3>
            <p>Metrics are sets of related measurements of attributes of systems. In the scope of monitoring, usually metrics are collected as timeseries data with a numerical value (that is, numbers associated with timestamps), like how many requests have been served with a certain status code over the last minute. Besides numerical timeseries, boolean timeseries are also nowadays commonplace, like "is the service X up or not", as well as others with string-like values to represent, for example, "the value of configuration X at time Y."</p>
        </div>
        <div class="col-5 u-hide--medium u-hide--small u-align--center u-vertically-center">
            {{ image (
                url="https://assets.ubuntu.com/v1/df2f25e5-metrics.svg",
                alt="",
                width="240",
                height="200",
                hi_def=True,
                loading="lazy"
                ) | safe
            }}
        </div>
    </div>
    <br>
    <div class="row u-equal-height">
        <div class="col-5 u-hide--medium u-hide--small u-align--center u-vertically-center">
            {{ image (
                url="https://assets.ubuntu.com/v1/699736cf-logs.svg",
                alt="",
                width="240",
                height="200",
                hi_def=True,
                loading="lazy"
                ) | safe
            }}
        </div>
        <div class="col-7">
            <h3 class="p-heading--4">Logs</h3>
            <p>Logs, structured (usually as JSON objects) or unstructured (as plain text following some pattern), are time-stamped entries that document the occurrence of an event like "the following error was caught" or "that payment process has been completed."</p>
        </div>
    </div>
    <br>
    <div class="row u-equal-height">
        <div class="col-7">
            <h3 class="p-heading--4">Distributed traces</h3>
            <p>Distributed traces document what work is done by various systems to process specific requests, like serving a Web page or executing a batch job. Nowadays, most distributed traces are modeled as a tree of spans. Spans are similar to structured logs, each describing some processing like "Serving request XYZ" or "Querying database 123", have a duration that reports how long it took to perform the processing, and have hierarchical relations to other spans in the form of child-parent relations. Usually, multiple systems contribute spans to one distributed trace, ranging from the API servers to databases and messaging queues and (micro)services in between.</p>
        </div>
        <div class="col-5 u-hide--medium u-hide--small u-align--center u-vertically-center">
            {{ image (
                url="https://assets.ubuntu.com/v1/53a1b740-distributed-tracing.svg",
                alt="",
                width="240",
                height="200",
                hi_def=True,
                loading="lazy"
                ) | safe
            }}
        </div>
    </div>
    <br>
    <div class="row u-equal-height">
        <div class="col-5 u-hide--medium u-hide--small u-align--center u-vertically-center">
            {{ image (
                url="https://assets.ubuntu.com/v1/32c10814-production-profiling.svg",
                alt="",
                width="240",
                height="200",
                hi_def=True,
                loading="lazy"
                ) | safe
            }}
        </div>
        <div class="col-7">
            <h3 class="p-heading--4">Production profiling</h3>
            <p>Production profiling identifies hot spots of resource consumption by continuously sampling, with limited performance overhead, which parts of your application consume CPU cycles, memory and, depending on the runtime, the amount of wait time, or asynchronous wait. Production profiling is usually very useful in getting you started when troubleshooting latency and memory usage spikes in the absence of more detailed telemetry. The "production" reference is due to the tradeoffs in the design of the profiler to optimise for minimal overhead, as opposed to profilers used in development that tend to optimise for precision.</p>
        </div>
    </div>
    <br>
    <div class="row u-equal-height">
        <div class="col-7">
            <h3 class="p-heading--4">Real user monitoring</h3>
            <p>Real user monitoring is about collecting telemetry about user sessions occurring via interfaces like web pages, mobile applications and sometimes IoT devices; real user monitoring is closely related with distributed tracing, in which a user session is correlated with one or more distributed traces, each describing, for example, how one asset or XHR request is served to the user interface.</p>
        </div>
        <div class="col-5 u-hide--medium u-hide--small u-align--center u-vertically-center">
            {{ image (
                url="https://assets.ubuntu.com/v1/f8ac79f6-real-user-monitoring.svg",
                alt="",
                width="180",
                height="150",
                hi_def=True,
                loading="lazy"
                ) | safe
            }}
        </div>
    </div>
    <br>
    <div class="row u-equal-height">
        <div class="col-5 u-hide--medium u-hide--small u-align--center u-vertically-center">
            {{ image (
                url="https://assets.ubuntu.com/v1/5d436760-synthetic-monitoring.svg",
                alt="",
                width="180",
                height="150",
                hi_def=True,
                loading="lazy"
                ) | safe
            }}
        </div>
        <div class="col-7">
            <h3 class="p-heading--4">Synthetic monitoring</h3>
            <p>Synthetic monitoring checks are continuously test systems, mostly production ones, to ensure that particular APIs or even entire user flows in UIs, like a checkout process, work as intended; in other words, synthetic monitoring checks are smoke tests for APIs and UIs.</p>
        </div>
    </div>
</section>

<section class="p-strip--light">
    <div class="row">
        <div class="col-12">
            <h2>Telemetry correlation for deeper insights</h2>
            <h3 class="p-heading--4">Making the most out of your metrics, logs, distributed traces and more</h3>
            <p>The various telemetry types provide you with more insight when they are correlated with one another.</p>
            <p>
                {{ image (
                    url="https://assets.ubuntu.com/v1/cf7d3849-telemetry-map-v2.svg",
                    alt="Diagram of observability components of a system: logs, metrics, distributed traces, production profiling, synthetic and end-user monitoring. Logs, synthetic and end-user monitoring are correlated with distributed tracing via trace context data; metrics and distributed traces via exemplars.",
                    width="950",
                    height="740",
                    hi_def=True,
                    loading="lazy",
                    attrs={"style": "padding: 2rem 0;", "class":"u-hide--small"},
                    ) | safe
                }}
            </p>
            <p>For example, Prometheus exemplars allow you to tag metrics with some sample distributed trace identifiers, so that you can drill down into some of the traces that affected specific metrics.</p>
            <p>Another commonplace correlation of telemetry is adding the trace context identifier to the metadata of logs, so that you can go from viewing a single log to seeing the entire execution flow across all components and services involved in an event.</p>
        </div>
    </div>
</section>

<section class="p-strip">
      <div class="row">
        <div class="col-12">
            <h2>Telemetry context</h2>
            <p>An often underrated aspect of telemetry is its context; that is, which system is the telemetry coming from, where is that system running and, by extension, what is the relation (or lack thereof) between this piece of telemetry and others. You could think of this as correlating telemetry with the topology of the monitored systems.</p>
            {{ image (
                url="https://assets.ubuntu.com/v1/485bb400-telemetry+types-substrates+and+context-02.svg",
                alt="Types of telemetry at the different substrate levels, namely bare metal, virtualization, operating system, containers and serverless, applications and end-user devices. Metrics and logs are prevalent across all the substrates; end-user monitoring and distributed tracing are at application level, production profiling is found between the application and operating system substrates.",
                width="925",
                height="488",
                hi_def=True,
                loading="lazy",
                attrs={"style": "padding: 2rem 0;", "class":"u-hide--small"},
                ) | safe
            }}
            <p>Telemetry context is increasingly encoded via tagging: adding consistent, curated tags to timeseries metrics, logs, distributed traces and so on, so that one can filter all the available telemetry for that generated by a specific set of machines, processes or other system components in a specific time interval.</p>
            <p>Another important function of telemetry context is to avoid confusion or outright mistakes when processing similar telemetry from unrelated deployments. For example, most alerting rules one may want to define for production databases should focus on specific clusters in specific regions, rather than "alert me when the 95th percentile of CPU usage across all my MySQL instances is above a threshold".</p>
        </div>
    </div>
</section>

<section class="p-strip--light">
    <div class="row">
        <div class="col-8">
            <h2>Controllability: observability in action</h2>
            <h3 class="p-heading--4">The forgotten twin to observability</h3>
            <p>The concept of observability originates in the field of modern control system theory, and its formulation has well withstood the test of time. And it was not a standalone concept either. Rather, observability had a twin concept, called controllability, which can be roughly defined as: "the property of a system to regulate itself and related systems to reliably produce the correct outputs given the provided inputs."</p>
            <p>Nowadays, controllability is not a term many software engineers use daily, but its essence is embodied, for example, by operators <a href="https://jaas.ai/?_ga=2.74388370.1830430303.1624442919-1608689799.1623932549">implemented with Juju</a>  or other frameworks, which steer the software they operate and the infrastructure underneath to provide seamless configuration management and achieve scalability, reliability and graceful degradation.</p>
            <a class="p-button--positive" href="/blog/tag/model-driven-operations">Learn more about model-driven operations</a>
        </div>
        <div class="col-4 u-vertically-center">
            <div style="background-color:#fff; border: 1px solid #eee; padding: 1rem;">
                <h4>Did you know?</h4>
                <p> The concept of observability was originally introduced by R. Kalman in 1960 in the field of modern control system theory, and its original meaning is largely still applicable to recent software, including cloud-native applications.</p>
              </div>
        </div>
    </div>
</section>

<section class="p-strip">
    <div class="row u-vertically-center">
        <div class="col-5 u-hide--medium u-hide--small u-hide--medium u-hide--small u-align--center">
            {{ image (
                url="https://assets.ubuntu.com/v1/e68fd355-1+discovery_AW.svg",
                alt="",
                width="403",
                height="230",
                hi_def=True,
                loading="auto"
                ) | safe
            }}
        </div>
        <div class="col-7">
            <h2>Ready to make your applications observable?</h2>
            <p>Canonical can support your open source observability stack with security fixes and LTS support, as well as run your best-of-breed, open source monitoring tools reliably and at scale.</p>
            <a class="p-button--positive" href="/observability">More about open source observability</a>
        </div>
    </div>
</section>


{% endblock content %}
